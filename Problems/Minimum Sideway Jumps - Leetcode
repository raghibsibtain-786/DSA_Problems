class Solution { // DFS
    public int[][] dp;
    public int dfs(int[] obstacles, int n, int index, int lane){
        while(index<n && obstacles[index]!=lane)
            index++;
        
        index--;
        
        if(index==n-1)
            return 0;
        
        int ans = Integer.MAX_VALUE;
        for(int obstacle: new int[]{1,2,3})
        {
            if(obstacles[index]!=obstacle && obstacles[index+1]!=obstacle) 
                //basically this obstacle is telling me 
                //how if it is same as obstacles[index]
                ans = Math.min(ans, (1+dfs(obstacles,n,index+1,obstacle)));
        }
        return ans;
    }
    public int minSideJumps(int[] obstacles) {
        
        int[][] dp = new int[obstacles.length][3];
        int n = obstacles.length;
        return dfs(obstacles,n,0,2);    
    }
}
